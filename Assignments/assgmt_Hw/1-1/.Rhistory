str(Customer)
Customer <- Customer[,-c(15:18)] #15,16,17행을 지운 Customer을 Customer에 재할당 (x,x1,x2,x3 변수 삭제)
str(Customer)
A <- Customer[Customer$추정가구소득==NA,]
A
A
A <- Customer[Customer$추정가구소득1==NA,]
A
Customer <- read.csv(header=T,customerURL,stringsAsFactors = F) #구글드라이브의 파일을 R이 string을 Factor로 변환하지 않는 조건으로 불러들인다
str(Customer)
Customer <- Customer[,-c(15:18)] #15,16,17행을 지운 Customer을 Customer에 재할당 (x,x1,x2,x3 변수 삭제)
str(Customer)
A <- Customer[Customer$추정가구소득1==NA,]
A
A <- Customer[is.na(customer$추정가구소득1),]
A <- Customer[is.na(customer$추정가구소득1),]
A <- Customer[is.na(Customer$추정가구소득1),]
A
A <- subset(Customer,추정가구소득1==NA)
A
Customer <- read.csv(header=T,customerURL,stringsAsFactors = F) #구글드라이브의 파일을 R이 string을 Factor로 변환하지 않는 조건으로 불러들인다
str(Customer)
Customer <- Customer[,-c(15:18)] #15,16,17행을 지운 Customer을 Customer에 재할당 (x,x1,x2,x3 변수 삭제)
str(Customer)
A <- subset(Customer,추정가구소득1==NA)
A
A
Customer
A <- subset(Customer,추정가구소득2==NA)
A
A <- Customer[Customer$추정가구소득2]
A <- Customer[Customer$추정가구소득2]
A <- Customer[Customer$추정가구소득2]
Customer <- read.csv(customerURL,stringsAsFactors = F) #구글드라이브의 파일을 R이 string을 Factor로 변환하지 않는 조건으로 불러들인다
str(Customer)
Customer <- Customer[,-c(15:18)] #15,16,17행을 지운 Customer을 Customer에 재할당 (x,x1,x2,x3 변수 삭제)
str(Customer)
A <- Customer[Customer$]
A
Customer
A <- Customer[Customer$추정가구소득2]
추정가구소득2
Customer <- read.csv(header=T,customerURL,stringsAsFactors = F) #구글드라이브의 파일을 R이 string을 Factor로 변환하지 않는 조건으로 불러들인다
str(Customer)
Customer <- Customer[,-c(15:18)] #15,16,17행을 지운 Customer을 Customer에 재할당 (x,x1,x2,x3 변수 삭제)
str(Customer)
A <- Customer[Customer$추정가구소득2]
A <- Customer[Customer$추정가구소득2]
Customer <- read.csv(header=T,customerURL,stringsAsFactors = F) #구글드라이브의 파일을 R이 string을 Factor로 변환하지 않는 조건으로 불러들인다
str(Customer)
Customer <- Customer[,-c(15:18)] #15,16,17행을 지운 Customer을 Customer에 재할당 (x,x1,x2,x3 변수 삭제)
str(Customer)
A <- Customer[Customer$추정가구소득2]
A
Customer
추정가구소득2
sum(is.na(Customer$추정가구소득1))
sum(is.na(Customer$추정가구소득1==NA))
sum(is.na(Customer$추정가구소득1))
sum(is.na(Customer$추정가구소득1))
sum(is.na(Customer$추정가구소득2))
sum(is.na(Customer$추정가구소득1))
sum(is.na(Customer$추정가구소득2))
#통계함수를 사용하는 등의 처리를 위해 N/A값을 알맞게 변경해줘야 하는데 예를들어 추정 가구소득 등의 평균을 구하는 상황에서 N/A값을 0으로 설정해버리면 해당값이 extreme value로써 통계에 불합리하게 작용할 것이므로 굳이 0으로 조정하지 않고 통계처리를 할 때 통계함수의 매개변수를 입력할 때 na.rm=T 을 적용하여 NA를 배제하고 통계를 분석할 것입니다.
SUM(is.na(Cusotmer$주택가격))
#통계함수를 사용하는 등의 처리를 위해 N/A값을 알맞게 변경해줘야 하는데 예를들어 추정 가구소득 등의 평균을 구하는 상황에서 N/A값을 0으로 설정해버리면 해당값이 extreme value로써 통계에 불합리하게 작용할 것이므로 굳이 0으로 조정하지 않고 통계처리를 할 때 통계함수의 매개변수를 입력할 때 na.rm=T 을 적용하여 NA를 배제하고 통계를 분석할 것입니다.
sum(is.na(Cusotmer$주택가격))
#통계함수를 사용하는 등의 처리를 위해 N/A값을 알맞게 변경해줘야 하는데 예를들어 추정 가구소득 등의 평균을 구하는 상황에서 N/A값을 0으로 설정해버리면 해당값이 extreme value로써 통계에 불합리하게 작용할 것이므로 굳이 0으로 조정하지 않고 통계처리를 할 때 통계함수의 매개변수를 입력할 때 na.rm=T 을 적용하여 NA를 배제하고 통계를 분석할 것입니다.
sum(is.na(Customer$주택가격))
#통계함수를 사용하는 등의 처리를 위해 N/A값을 알맞게 변경해줘야 하는데 예를들어 추정 가구소득 등의 평균을 구하는 상황에서 N/A값을 0으로 설정해버리면 해당값이 extreme value로써 통계에 불합리하게 작용할 것이므로 굳이 0으로 조정하지 않고 통계처리를 할 때 통계함수의 매개변수를 입력할 때 na.rm=T 을 적용하여 NA를 배제하고 통계를 분석할 것입니다.
sum(is.na(Customer$연령))
sum(is.na(Customer$직업그룹코드1))
sum(is.na(Customer$시도구분))
sum(is.na(Customer$FP경력))
sum(is.na(Customer$주택가격))
sum(is.na(Customer$추정가구소득1)) #추정가구소득1 변수엔 결측값이 존재하지 않음을 볼 수 있다
sum(is.na(Customer$추정가구소득2)) #추정가구소득2 변수엔 결측값이 680개 존재함을 확인할 수 있다. 주의해야 할 것은 추정가구소득2의 통계분석입니다.
Customer
Customer[Customer$연령]
Customer[Customer$연령령]
Customer[Customer$연령]
Customer[Customer$연령==1]
Customer$연령령
Customer$연령
Age <- Customer$연령
#고객을 연령대별로 통계
Age <- Customer$연령
#고객을 연령대별로 통계
Age <- Customer$연령
Age >= 20
#고객을 연령대별로 통계
Age <- Customer$연령
Age >= 50
#고객을 연령대별로 통계
Age <- Customer$연령
Age >= 100
#고객을 연령대별로 통계
Age <- Customer$연령
length(which(Age=<30))
#고객을 연령대별로 통계
Age <- Customer$연령
length(which(Age<+30))
#고객을 연령대별로 통계
Age <- Customer$연령
length(which(Age<=30))
#고객을 연령대별로 통계
Age <- Customer$연령
length(which(Age<=30))
#고객을 연령대별로 통계
Age <- Customer$연령
length(which(Age<=30))
Customer <- read.csv(header=T,customerURL,stringsAsFactors = F) #구글드라이브의 파일을 R이 string을 Factor로 변환하지 않는 조건으로 불러들인다
str(Customer)
Customer <- Customer[,-c(15:18)] #15,16,17행을 지운 Customer을 Customer에 재할당 (x,x1,x2,x3 변수 삭제)
str(Customer)
sum(is.na(Customer$연령))   #연령 변수엔 결측값이 존재하지 않음을 볼 수 있다
sum(is.na(Customer$직업그룹코드1)) #직업그룹코드1 변수엔 결측값이 존재하지 않음을 볼 수 있다
sum(is.na(Customer$시도구분)) #시도구분 변수엔 결측값이 존재하지 않음을 볼 수 있다.
sum(is.na(Customer$FP경력)) #FP경력 변수엔 결측값이 존재하지 않음을 볼 수 있다.
sum(is.na(Customer$주택가격)) #주택가격 변수엔 결측값이 존재하지 않음을 볼 수 있다.
sum(is.na(Customer$추정가구소득1)) #추정가구소득1 변수엔 결측값이 존재하지 않음을 볼 수 있다
sum(is.na(Customer$추정가구소득2)) #추정가구소득2 변수엔 결측값이 680개 존재함을 확인할 수 있다.
#고객을 연령대별로 통계
Age <- Customer$연령
length(which(Age<=30))
#고객을 연령대별로 통계
Age <- Customer$연령
length(which(Age<=30))
length(which(age>30 | age<=40))
length(which(Age>30 | Age<=40))
length(which(Age>30 & Age<=40))
#고객을 연령대별로 통계
Age <- Customer$연령
length(which(Age<=30))
length(which(Age>30 & Age<=40))
length(which(Age>40 & Age<=50)) #40~50살 까지의 고객 수수
length(which(Age>50 & Age<=60))
length(which(Age>60 & Age<=70))
length(which(Age>70 & Age<=80))
length(which(Age>80 & Age<=90))
length(which(Age>90 & Age<=100))
min(Age)
max(Age)
length(which(Age>90 & Age<=100))
Age <- Customer$연령
Age.Range.Freq <-function(x,a,b){   #
length(which(x>a & x<=a))
}
Age.Range.Freq(Age,30,40)
return(c)}
Age <- Customer$연령
Age.Range.Freq <-function(x,a,b){   #
c <- length(which(x>a & x<=a))
return(c)}
Age.Range.Freq(Age,30,40)
length(which(Age>30 & Age<=40)) #30~40살 사이의 고객 수
Age <- Customer$연령
Age.Range.Freq <-function(x,a,b){   #
c <- length(which(x>a & x<=b))
return(c)}
Age.Range.Freq(Age,30,40)
customerURL <- "http://bitly.kr/Mv61KM6A5"
Customer <- read.csv(header=T,customerURL,stringsAsFactors = F) #구글드라이브의 파일을 R이 string을 Factor로 변환하지 않는 조건으로 불러들인다
str(Customer)
Customer <- Customer[,-c(15:18)] #15,16,17행을 지운 Customer을 Customer에 재할당 (x,x1,x2,x3 변수 삭제)
str(Customer)
sum(is.na(Customer$연령))   #연령 변수엔 결측값이 존재하지 않음을 볼 수 있다
sum(is.na(Customer$직업그룹코드1)) #직업그룹코드1 변수엔 결측값이 존재하지 않음을 볼 수 있다
sum(is.na(Customer$시도구분)) #시도구분 변수엔 결측값이 존재하지 않음을 볼 수 있다.
sum(is.na(Customer$FP경력)) #FP경력 변수엔 결측값이 존재하지 않음을 볼 수 있다.
sum(is.na(Customer$주택가격)) #주택가격 변수엔 결측값이 존재하지 않음을 볼 수 있다.
sum(is.na(Customer$추정가구소득1)) #추정가구소득1 변수엔 결측값이 존재하지 않음을 볼 수 있다
sum(is.na(Customer$추정가구소득2)) #추정가구소득2 변수엔 결측값이 680개 존재함을 확인할 수 있다.
min(Age)   #최연소 고객은 2세
max(Age)   #최고령 고객은 89세
Age <- Customer$연령 #연령 열만 Age로 선언
#고객 연령대별 Histogram작성을 위해 Age를 7개의 class로 분류하여 빈도수를 세고자 합니다.
Age.Range.Freq <-function(x,a,b){   # 매개변수를 x,a,b로 X에 vector를받아 a보다 크고 b보다 작은 값의 빈도를 간편하게 세기 위해 함수를 만들겠습니다
c <- length(which(x>a & x<=b))
return(c)}                        # 결과로 c를 반환하도록 설정합니다
Age.Range.Freq(Age,30,40)
length(which(Age<=30)) #~30살 까지의 고객 수
length(which(Age>30 & Age<=40)) #30~40살 사이의 고객 수
length(which(Age>40 & Age<=50)) #40~50살 사이의 고객 수
length(which(Age>50 & Age<=60)) #50~60살 사이의 고객 수
length(which(Age>60 & Age<=70)) #60~70살 사이의 고객 수
length(which(Age>70 & Age<=80)) #70~80살 사이의 고객 수
length(which(Age>80 & Age<=90)) #80~90살 사이의 고객 수
Age.Range.Freq(Age,min(age),30)  #~30살 까지의 고객 수
Age.Range.Freq(Age,min(Age),30)  #~30살 까지의 고객 수
Age.Range.Freq(Age,min(Age),30)  #~30살 까지의 고객 수
Age.Range.Freq(Age,30,40) #30~40살 사이의 고객 수
Age.Range.Freq(Age,40,50) #40~50살 사이의 고객 수
Age.Range.Freq(Age,50,60) #50~60살 사이의 고객 수
Age.Range.Freq(Age,60,70) #60~70살 사이의 고객 수
Age.Range.Freq(Age,70,80) #70~80살 사이의 고객 수
Age.Range.Freq(Age,80,90) #80~90살 사이의 고객 수
Age.Range.Freq(Age,0,10)  #~30살 까지의 고객 수
Age.Range.Freq(Age,10,20)
Age.Range.Freq(Age,30,40) #30~40살 사이의 고객 수
Age.Range.Freq(Age,40,50) #40~50살 사이의 고객 수
Age.Range.Freq(Age,50,60) #50~60살 사이의 고객 수
Age.Range.Freq(Age,0,10)  #~30살 까지의 고객 수
Age.Range.Freq(Age,10,20)
Age.Range.Freq(Age,30,40) #30~40살 사이의 고객 수
Age.Range.Freq(Age,40,50) #40~50살 사이의 고객 수
Age.Range.Freq(Age,50,60) #50~60살 사이의 고객 수
Age.Range.Freq(Age,60,70) #60~70살 사이의 고객 수
Age.Range.Freq(Age,70,80) #70~80살 사이의 고객 수
Age.Range.Freq(Age,80,90) #80~90살 사이의 고객 수
Age.Range.Freq(Age,0,10)  #0~10살 까지의 고객 수
Age.Range.Freq(Age,10,20) #10~20살 까지의 고객 수
Age.Range.Freq(Age,20,30)
Age.Range.Freq(Age,30,40) #30~40살 사이의 고객 수
Age.Range.Freq(Age,40,50) #40~50살 사이의 고객 수
Age.Range.Freq(Age,50,60) #50~60살 사이의 고객 수
Age.Range.Freq(Age,60,70) #60~70살 사이의 고객 수
Age.Range.Freq(Age,70,80) #70~80살 사이의 고객 수
Age.Range.Freq(Age,80,90) #80~90살 사이의 고객 수
Age.Range.Freq(Age,0,10)  #0~10살 까지의 고객 수
Age.Range.Freq(Age,10,20) #10~20살 까지의 고객 수
Age.Range.Freq(Age,20,30)
Age.Range.Freq(Age,30,40) #30~40살 사이의 고객 수
Age.Range.Freq(Age,40,50) #40~50살 사이의 고객 수
Age.Range.Freq(Age,50,60) #50~60살 사이의 고객 수
Age.Range.Freq(Age,60,70) #60~70살 사이의 고객 수
Age.Range.Freq(Age,70,80) #70~80살 사이의 고객 수
Age.Range.Freq(Age,80,90) #80~90살 사이의 고객 수
summary(Customer)
hist()
hist(Age)
Age.Range.Freq(Age,0,10)  #0~10살 사이의 고객 수
Age.Range.Freq(Age,10,20) #10~20살 사이의 고객 수
Age.Range.Freq(Age,20,30) #20~30살 사이의 고객 수
Age.Range.Freq(Age,30,40) #30~40살 사이의 고객 수
Age.Range.Freq(Age,40,50) #40~50살 사이의 고객 수
Age.Range.Freq(Age,50,60) #50~60살 사이의 고객 수
Age.Range.Freq(Age,60,70) #60~70살 사이의 고객 수
Age.Range.Freq(Age,70,80) #70~80살 사이의 고객 수
Age.Range.Freq(Age,80,90) #80~90살 사이의 고객 수
hist(Age)
summary(Customer) #Customer내의 각 변수에 관한 기본적 통계 요약출력
mean(Age)
median(Age) #중간 나이
Mode(Age)
mode(Age)
summary(Customer) #Customer내의 각 변수에 관한 기본적 통계 요약출력
Customer[Customer$FP경력=="Y"]
#추정가구소득의 통계를 분석해보겠습니다. 추정가구소득1을 할 수도 있겠지만 , 해당 데이터셋에서 NA값을 가진  유일한 변수인 추정가구소득2를 다루도록 하겠습니다.
<-Customer$Fp경력
#추정가구소득의 통계를 분석해보겠습니다. 추정가구소득1을 할 수도 있겠지만 , 해당 데이터셋에서 NA값을 가진  유일한 변수인 추정가구소득2를 다루도록 하겠습니다.
Customer$Fp경력
#추정가구소득의 통계를 분석해보겠습니다. 추정가구소득1을 할 수도 있겠지만 , 해당 데이터셋에서 NA값을 가진  유일한 변수인 추정가구소득2를 다루도록 하겠습니다.
FP<-Customer$Fp경력
FP
Customer <- read.csv(header=T,customerURL,stringsAsFactors = F) #구글드라이브의 파일을 R이 string을 Factor로 변환하지 않는 조건으로 불러들인다
str(Customer)
Customer <- Customer[,-c(15:18)] #15,16,17행을 지운 Customer을 Customer에 재할당 (x,x1,x2,x3 변수 삭제)
str(Customer)
sum(is.na(Customer$연령))   #연령 변수엔 결측값이 존재하지 않음을 볼 수 있다
sum(is.na(Customer$직업그룹코드1)) #직업그룹코드1 변수엔 결측값이 존재하지 않음을 볼 수 있다
sum(is.na(Customer$시도구분)) #시도구분 변수엔 결측값이 존재하지 않음을 볼 수 있다.
sum(is.na(Customer$FP경력)) #FP경력 변수엔 결측값이 존재하지 않음을 볼 수 있다.
sum(is.na(Customer$주택가격)) #주택가격 변수엔 결측값이 존재하지 않음을 볼 수 있다.
sum(is.na(Customer$추정가구소득1)) #추정가구소득1 변수엔 결측값이 존재하지 않음을 볼 수 있다
sum(is.na(Customer$추정가구소득2)) #추정가구소득2 변수엔 결측값이 680개 존재함을 확인할 수 있다.
#추정가구소득의 통계를 분석해보겠습니다. 추정가구소득1을 할 수도 있겠지만 , 해당 데이터셋에서 NA값을 가진  유일한 변수인 추정가구소득2를 다루도록 하겠습니다.
FP<-Customer$Fp경력
FP
#추정가구소득의 통계를 분석해보겠습니다. 추정가구소득1을 할 수도 있겠지만 , 해당 데이터셋에서 NA값을 가진  유일한 변수인 추정가구소득2를 다루도록 하겠습니다.
FP<-Customer$FP경력
FP
FPY<-FP=="Y"
FPY
FPY<-FP=="Y"
FPY
#추정가구소득의 통계를 분석해보겠습니다. 추정가구소득1을 할 수도 있겠지만 , 해당 데이터셋에서 NA값을 가진  유일한 변수인 추정가구소득2를 다루도록 하겠습니다.
CustFPY <- Customer[Customer$FP경력==T,]
#추정가구소득의 통계를 분석해보겠습니다. 추정가구소득1을 할 수도 있겠지만 , 해당 데이터셋에서 NA값을 가진  유일한 변수인 추정가구소득2를 다루도록 하겠습니다.
CustFPY <- Customer[Customer$FP경력=="Y",]
cUSTFPY
CUSTFPY
CustFPY
CustFPY <- Customer[Customer$FP경력=="Y",] #Customer중 FP경력이 있는 고객만 서브셋 하겠습니다.
CustFPY <- Customer[Customer$Fp경력=="N",] #Customer중 Fp경력이 없는 고객만 서브셋 하겠습니다.
CustFPY
CustFPY
CustFPY <- Customer[Customer$FP경력=="Y",] #Customer중 FP경력이 있는 고객만 서브셋 하겠습니다.
CustFPY
CustFPN <- Customer[Customer$FP경력=="N",] #Customer중 Fp경력이 없는 고객만 서브셋 하겠습니다.
CustFPN
FPYHouseP<- CustFPY$주택가격
FPYHouseP<- CustFPN$주택가격
FP<-Customer$FP경력 #FP경력 변수를 FP라는 변수로 선언
FPYHouseP<- mean(CustFPY$주택가격)
FPYHouseP<- mean(CustFPN$주택가격)
FPYHouseP<- mean(CustFPY$주택가격) #FP경력이 있는 고객들의 주택가격의 평균을 선언
FPYHouseP<- mean(CustFPN$주택가격) #FP경력이 없는 고객들의 주택가격의 평균을 선언
FPYHouseP<- mean(CustFPY$주택가격) #FP경력이 있는 고객들의 주택가격의 평균을 선언
FPNHouseP<- mean(CustFPN$주택가격) #FP경력이 없는 고객들의 주택가격의 평균을 선언
FPYHouseP
FPNHouseP
#이 둘을 비교해
FPYHouseP
FPNHouseP
#FP경력과 추정가구소득2의 상관관계
FPYIncome <- mean(CustFPY$추정가구소득2)
FPNIncome <- mean(CustFPY$추정가구소득2)
#FP경력과 추정가구소득2의 상관관계
FPYIncome <- mean(CustFPY$추정가구소득2)
FPNIncome <- mean(CustFPN$추정가구소득2)
FPYIncome
FPNIncome
#FP경력과 추정가구소득2의 상관관계
FPYIncome <- mean(CustFPY$추정가구소득2)
FPYIncome
#FP경력과 추정가구소득2의 상관관계
FPYIncome <- mean(CustFPY$추정가구소득2,na.rm=T) #FP경력이 있는 고객들의 평균 추정가구소득2, 추정가구소득2엔 NA값이 포함돼있는것을 잊지말고 na.rm=T 로 설정하여 분석
FPNIncome <- mean(CustFPN$추정가구소득2,na.rm=T) #FP경력이 없는 고객들의 평균 추정가구소득2
FPYIncome
FPNIncome
FPYIncome>FPNIncome
customerURL <- "http://bitly.kr/Mv61KM6A5"
Customer <- read.csv(customerURL)
Customer
#---------------------------------------------------
customerURL <- "http://bitly.kr/Mv61KM6A5"
Customer <- read.csv(header=T,customerURL,stringsAsFactors = F) #구글드라이브의 파일을 R이 string을 Factor로 변환하지 않는 조건으로 불러들인다
str(Customer)
#해당 Customer 데이터프레임의 구조를 살펴보면 X X.1 X.2 X.3 에 해당하는 변수 네 가지는 유의미한 value를 가지고 있지 않으므로 지워줄 필요가 있습니다.
Customer <- Customer[,-c(15:18)] #15,16,17행을 지운 Customer을 Customer에 재할당 (x,x1,x2,x3 변수 삭제)
str(Customer)
#통계함수를 사용하는 등의 처리를 위해 N/A값을 알맞게 변경해줘야 하는데 예를들어 추정 가구소득 등의 평균을 구하는 상황에서 N/A값을 0으로 설정해버리면 해당값이 extreme value로써 통계에 불합리하게 작용할 것이므로 굳이 0으로 조정하지 않고 통계처리를 할 때 통계함수의 매개변수를 입력할 때 na.rm=T 을 적용하여 NA를 배제하고 통계를 분석할 것입니다.
#관심있게 다룰만한 변수만 골라서 NA값 존재여부를 검사해봤습니다.
sum(is.na(Customer$연령))   #연령 변수엔 결측값이 존재하지 않음을 볼 수 있다
sum(is.na(Customer$직업그룹코드1)) #직업그룹코드1 변수엔 결측값이 존재하지 않음을 볼 수 있다
sum(is.na(Customer$시도구분)) #시도구분 변수엔 결측값이 존재하지 않음을 볼 수 있다.
sum(is.na(Customer$FP경력)) #FP경력 변수엔 결측값이 존재하지 않음을 볼 수 있다.
sum(is.na(Customer$주택가격)) #주택가격 변수엔 결측값이 존재하지 않음을 볼 수 있다.
sum(is.na(Customer$추정가구소득1)) #추정가구소득1 변수엔 결측값이 존재하지 않음을 볼 수 있다
sum(is.na(Customer$추정가구소득2)) #추정가구소득2 변수엔 결측값이 680개 존재함을 확인할 수 있다.
#검사결과 NA가 존재하는 변수는 추정가구소득2 뿐이므로,주의해야 할 것은 추정가구소득2의 통계분석입니다.
#------------------------------
#통계량
summary(Customer) #Customer내의 각 변수에 관한 기본적 통계 요약출력
#이중 제가 관심있는 몇가지 변수만 조금 더 구체적으로 살펴보겠습니다.
#먼저 연령입니다 , 고객을 연령대별로 통계하겠습니다.
Age <- Customer$연령 #연령 열만 Age로 선언
hist(Age) #먼저 hist()함수로 해당 변수의 histogram에 관해 시각적으로 살펴보고 가겠습니다.
#이를 보고 40~60세 사이의 고객수가 가장 많음을 대략적으로 파악할 수 있습니다.
#위의 Age 히스토그램에서 살펴본 내용을 조금 더 자세히 알아보겠습니다.
min(Age)   #최연소 고객은 2세
max(Age)   #최고령 고객은 89세
mean(Age)  #평균 나이 44.73세
median(Age) #중앙값 46세
#연령대로 class를 나누어 정확한 빈도수의 값을 알고싶습니다. 최연소 2세,최고령 89세 고객을 확인했으므로 0~90까지로 Range를 설정하겠습니다.
#7주차에 배운 function의 Define을 활용하여 과정을 함수화시키겠습니다.
Age.Range.Freq <-function(x,a,b){   # 매개변수를 x,a,b로 X에 vector를받아 a보다 크고 b보다 작은 값의 빈도를 간편하게 세기 위해 함수를 만들겠습니다
c <- length(which(x>a & x<=b))
return(c)}                        # 결과로 c를 반환하도록 설정합니다
Age.Range.Freq(Age,0,10)  #0~10살 사이의 고객 수    #call
Age.Range.Freq(Age,10,20) #10~20살 사이의 고객 수   #call
Age.Range.Freq(Age,20,30) #20~30살 사이의 고객 수   #call
Age.Range.Freq(Age,30,40) #30~40살 사이의 고객 수   #call
Age.Range.Freq(Age,40,50) #40~50살 사이의 고객 수   #call
Age.Range.Freq(Age,50,60) #50~60살 사이의 고객 수   #call
Age.Range.Freq(Age,60,70) #60~70살 사이의 고객 수   #call
Age.Range.Freq(Age,70,80) #70~80살 사이의 고객 수   #call
Age.Range.Freq(Age,80,90) #80~90살 사이의 고객 수   #call
#50~60의 클래스가 가장 큽니다. 보험사기자여부의 항목이 있는것으로 보아 해당 데이터셋은 증권사 또는 보험사의 고객데이터셋으로 추정되는데, 50~60세의 장년층은 일반적인 라이프사이클에 비춰 봤을때 저축해둔 자산이 비교적 많거나, 노후에 대비해 어느정도의 투자를 해뒀을 확률이 높을 나이입니다. 해당 통계결과는 이러한 사실을 반영하는것으로 보입니다.
#추정가구소득의 통계를 분석해보겠습니다. 추정가구소득1을 할 수도 있겠지만 , 해당 데이터셋에서 NA값을 가진  유일한 변수인 추정가구소득2를 다루도록 하겠습니다.
#은행 FP경력이 가구소득 및 거주주택의 가격에 영향이 있는지 알아보고싶습니다. FP경력과 가구소득,주택가격 의 상관관계를 유추해보겠습니다.
#FP경력과 주택가격의 상관관계
CustFPY <- Customer[Customer$FP경력=="Y",] #Customer중 FP경력이 있는 고객만 서브셋 하겠습니다.
CustFPN <- Customer[Customer$FP경력=="N",] #Customer중 Fp경력이 없는 고객만 서브셋 하겠습니다.
FPYHouseP<- mean(CustFPY$주택가격) #FP경력이 있는 고객들의 주택가격의 평균을 선언
FPNHouseP<- mean(CustFPN$주택가격) #FP경력이 없는 고객들의 주택가격의 평균을 선언
#이 둘을 비교해 본 결과 오히려 FP경력이 없는 고객의 주택가격이 근소하게 높습니다. FP경력과 주택가격간 관게는 없거나 약한(weak),부정적(negative) 관계입니다
FPYHouseP>FPNHouseP
FPYHouseP
FPNHouseP
#FP경력과 추정가구소득2의 상관관계
FPYIncome <- mean(CustFPY$추정가구소득2,na.rm=T) #FP경력이 있는 고객들의 평균 추정가구소득2, 추정가구소득2엔 NA값이 포함돼있는것을 잊지말고 na.rm=T 로 설정하여 분석
FPNIncome <- mean(CustFPN$추정가구소득2,na.rm=T) #FP경력이 없는 고객들의 평균 추정가구소득2
FPYIncome>FPNIncome ; FPYIncome;FPNIncome
#FP경력이 있는 고객과 없는 고객의 평균소득을 분석해 본 결과,주택가격과의 관계와 다르게 FP경력고객이 무경력고객에 비해 소득평균이 대략 1000정도 앞서는 것으로 FP경력과 가구소득이 긍정의 관계임을 보여주며,이 차이값이 유의미한 수준입니다. 이로부터 FP경력과 추정가구소득2가 강한(strong),긍정(positive)의 관계를 가진다고 유추해 볼 수 있습니다.(물론 이는 여타 다른 변수를 무시하여 과장된 값일 수 있습니다)
#통계함수를 사용하는 등의 처리를 위해 N/A값을 알맞게 변경해줘야 하는데 예를들어 추정 가구소득 등의 평균을 구하는 상황에서 N/A값을 0으로 설정해버리면 해당값이 extreme value로써 통계에 불합리하게 작용할 것이므로 굳이 0으로 조정하지 않고 통계처리를 할 때 통계함수의 매개변수를 입력할 때 na.rm=T 을 적용하여 NA를 배제하고 통계를 분석할 것입니다.
#관심있게 다룰만한 변수만 골라서 NA값 존재여부를 검사해봤습니다.
sum(is.na(Customer$연령))   #연령 변수엔 결측값이 존재하지 않음을 볼 수 있다
sum(is.na(Customer$직업그룹코드1)) #직업그룹코드1 변수엔 결측값이 존재하지 않음을 볼 수 있다
sum(is.na(Customer$시도구분)) #시도구분 변수엔 결측값이 존재하지 않음을 볼 수 있다.
sum(is.na(Customer$FP경력)) #FP경력 변수엔 결측값이 존재하지 않음을 볼 수 있다.
sum(is.na(Customer$주택가격)) #주택가격 변수엔 결측값이 존재하지 않음을 볼 수 있다.
sum(is.na(Customer$추정가구소득1)) #추정가구소득1 변수엔 결측값이 존재하지 않음을 볼 수 있다
sum(is.na(Customer$추정가구소득2)) #추정가구소득2 변수엔 결측값이 680개 존재함을 확인할 수 있다.
#검사결과 NA가 존재하는 변수는 추정가구소득2 뿐이므로,주의해야 할 것은 추정가구소득2의 통계분석입니다.
customerURL <- "http://bitly.kr/Mv61KM6A5"
Customer <- read.csv(header=T,customerURL,stringsAsFactors = F) #구글드라이브의 파일을 R이 string을 Factor로 변환하지 않는 조건으로 불러들인다
str(Customer)
#해당 Customer 데이터프레임의 구조를 살펴보면 X X.1 X.2 X.3 에 해당하는 변수 네 가지는 유의미한 value를 가지고 있지 않으므로 지워줄 필요가 있습니다.
Customer <- Customer[,-c(15:18)] #15,16,17행을 지운 Customer을 Customer에 재할당 (x,x1,x2,x3 변수 삭제)
str(Customer)
mean(Customer$추정가구소득1)
mean(Customer$추정가구소득1)
#추정가구소득1의 평균 및 각 고객 별 평균과의 차이 계산
mean(Customer$추정가구소득1)
#FP경력과 추정가구소득2의 상관관계
FPYIncome <- mean(CustFPY$추정가구소득2,na.rm=T) #FP경력이 있는 고객들의 평균 추정가구소득2, 추정가구소득2엔 NA값이 포함돼있는것을 잊지말고 na.rm=T 로 설정하여 분석
FPNIncome <- mean(CustFPN$추정가구소득2,na.rm=T) #FP경력이 없는 고객들의 평균 추정가구소득2
FPYIncome>FPNIncome ; FPYIncome;FPNIncome
#FP경력이 있는 고객과 없는 고객의 평균소득을 분석해 본 결과,주택가격과의 관계와 다르게 FP경력고객이 무경력고객에 비해 소득평균이 대략 1000정도 앞서는 것으로 FP경력과 가구소득이 긍정의 관계임을 보여주며,이 차이값이 유의미한 수준입니다. 이로부터 FP경력이 추정가구소득2에 긍정적인(Positive) 영향력을 가진다고 유추해 볼 수 있습니다.(물론 이는 여타 다른 변수를 무시하여 과장된 값일 수 있습니다)
#추정가구소득의 통계를 분석해보겠습니다. 추정가구소득1을 할 수도 있겠지만 , 해당 데이터셋에서 NA값을 가진  유일한 변수인 추정가구소득2를 다루도록 하겠습니다.
#은행 FP경력이 가구소득 및 거주주택의 가격에 영향이 있는지 알아보고싶습니다. FP경력과 가구소득,주택가격 의 관계를 유추하고자 합니다.
#FP경력과 주택가격의 관계 분석
CustFPY <- Customer[Customer$FP경력=="Y",] #Customer중 FP경력이 있는 고객만 서브셋 하겠습니다.
CustFPN <- Customer[Customer$FP경력=="N",] #Customer중 Fp경력이 없는 고객만 서브셋 하겠습니다.
FPYHouseP<- mean(CustFPY$주택가격) #FP경력이 있는 고객들의 주택가격의 평균을 선언
FPNHouseP<- mean(CustFPN$주택가격) #FP경력이 없는 고객들의 주택가격의 평균을 선언
#이 둘을 비교해 본 결과 오히려 FP경력이 없는 고객의 주택가격이 근소하게 높습니다. FP경력과 주택가격간 관계는 없거나 약한(weak),부정적(negative) 관계입니다
FPYHouseP>FPNHouseP
FPYHouseP
FPNHouseP
mean(Customer$추정가구소득1)
Customer$추정가구소득1 - mean(Customer$추정가구소득1)
IncomeDiff <- Customer$추정가구소득1 - mean(Customer$추정가구소득1)
Head(IncomeDiff,5)
head(IncomeDiff,5)
Customer <-bind_rows(Customer,IncomeDiff)
Customer <-bind_rows(Customer,IncomeDiff)
#추정가구소득1의 평균 및 각 고객 별 평균과의 차이 계산
IncomeDiff <- Customer$추정가구소득1 - mean(Customer$추정가구소득1)
head(IncomeDiff,5) #해당변수의 앞 5개값만 보여줍니다.
#이를 Customer 데이터프레임의 변수로 추가
Customer <-bind_rows(Customer,IncomeDiff)
IncomeDiff <- Customer$추정가구소득1 - mean(Customer$추정가구소득1)
head(IncomeDiff,5) #해당변수의 앞 5개값만 보여줍니다.
Customer <-bind_rows(Customer,IncomeDiff)
Customer <-bind_rows(Customer,"IncomeDiff")
Customer$IncomeDiff <- IncomeDiff
#추정가구소득1의 평균 및 각 고객 별 평균과의 차이 계산
IncomeDiff <- Customer$추정가구소득1 - mean(Customer$추정가구소득1)
head(IncomeDiff,5) #해당변수의 앞 5개값만 보여줍니다.
#이를 Customer 데이터프레임의 변수로 추가
Customer$IncomeDiff <- IncomeDiff
head(Customer)
#추정가구소득1의 평균 및 각 고객 별 평균과의 차이 계산
IncomeDiff <- Customer$추정가구소득1 - mean(Customer$추정가구소득1)
head(IncomeDiff,5) #해당변수의 앞 5개값만 보여줍니다.
#이를 Customer 데이터프레임의 변수로 추가
Customer$IncomeDiff <- IncomeDiff
head(Customer)
head(Customer)
head(Customer)
#추정가구소득1의 평균과 각 고객 별 평균 추정가구소득1 과의 차이 계산
IncomeDiff <- Customer$추정가구소득1 - mean(Customer$추정가구소득1)
Customer$IncomeDiff <- IncomeDiff #IncomeDiff를  Customer 데이터프레임의 새로운 변수로 추가
head(Customer) head(IncomeDiff,5) #해당변수의 앞 5개값만 보여줍니다.
library(dplyr) # 파이프함수를 사용하기 위해 dplyr 패키지를 불러옴
#install.packages("leaflet") #지도 제작을 위해 leaflet 패키지를 불러옴
library(leaflet)
covid_case <- read.csv("http://bitly.kr/C5ykr25qI", stringsAsFactors = F)   # 문자열을 팩터로 변환하지 않는다는 조건으로 해당 링크에서 다루고자 하는 데이터프레임을 가져옵니다.
str(covid_case)
#전처리----------
covid_case$longitude <- as.numeric(covid_case$longitude)
covid_case$latitude <- as.numeric(covid_case$latitude)    ##str(covid_case)로 해당 데이터프레임의 구조를 확인해 본 결과 latitude(위도)/longitude(경도) 가 character로 설정되어 있어 차후 지도에 발생지를 표시하고자 할 때 문제가 될것이므로 ,밑의 as.numeric 과정으로 숫자형 데이터로 변환 시켜줍니다.
str(covid_case) #위도,경도가 numeric data로 변환된 것을 볼 수 있습니다.
names(covid_case)[c(5,7,8)] <- c("name","lat","long") #편의를 위해 발생지 , 위도 , 경도의 이름을 바꿔줍니다
str(covid_case)
covid_case
#해당 데이터를 살펴볼 때 위,경도가 NA값으로 들어간 데이터들이 존재하는데 이는 기존에 "-" 라고 Char Type으로 저장되어있던 data가 numeric형으로 변환되며 강제로 NA값을 부여받은 것이다. 몇개의 예외를 빼고 대부분의 경우 infection_case를 살펴 볼 때 위/경도가 존재하는 다른데이터들과 달리 특정 발생지를 말하는 것이 아닌 일반화 된 케이스를 말하고 있는 것이기 때문에 의도적으로(또는 몇몇경우 알아내지못해) 위/경도를 입력하지 않은 케이스로 보입니다.
#위도/경도에 city값을 기준으로 평균을 내서 작은 등차값을 주어 NA에 할당 할 수도 있겠으나, 해당 마킹 지도의 목적이 사용자에게 코로나 발생지를 알림으로써 주의를 주기위함임이라고 고려할 때 앞에 언급한 전처리는 불필요한데 더해 해석에 혼란을 야기할 수 있다고 생각하여 하지 않겠습니다. 더불어 위도/경도를 0으로 처리한다면 지도상 Mark가 지역의 도메인인 대한민국을 벗어나므로 이또한 하지 않겠습니다.
#-----------------
#해당 데이터셋에 케이스가 102개밖에 되지 않고 그마저도 위,경도가 포함된 데이터가 얼마 되지 않으므로 따로 서브셋시키지 않겠습니다.
m <- leaflet() %>%  #파이프함수를 사용하여 leaflet,addTiles,addMarkers 함수를 한번에 실행시켜줍니다.
addTiles() %>%
addMarkers(lng=covid_case$long, lat=covid_case$lat, popup=covid_case$name,)
m
#추정가구소득1의 평균과 각 고객 별 평균 추정가구소득1 과의 차이 계산
IncomeDiff <- Customer$추정가구소득1 - mean(Customer$추정가구소득1)
Customer$IncomeDiff <- IncomeDiff #IncomeDiff를  Customer 데이터프레임의 새로운 변수로 추가
head(Customer) #해당변수의 앞 5개값만 보여줍니다.
#연령대로 class를 나누어 정확한 빈도수의 값을 알고싶습니다. 최연소 2세,최고령 89세 고객을 확인했으므로 0~90까지로 Range를 설정하겠습니다.
#7주차에 배운 function의 Define을 활용하여 과정을 함수화시키겠습니다.
Age.Range.Freq <-function(x,a,b){   # 매개변수를 x,a,b로 X에 vector를받아 a보다 크고 b보다 작은 값의 빈도를 간편하게 세기 위해 함수를 만들겠습니다
c <- length(which(x>a & x<=b))
return(c)}                        # 결과로 c를 반환하도록 설정합니다
Age.Range.Freq(Age,0,10)  #0~10살 사이의 고객 수    #call
Age.Range.Freq(Age,10,20) #10~20살 사이의 고객 수   #call
Age.Range.Freq(Age,20,30) #20~30살 사이의 고객 수   #call
Age.Range.Freq(Age,30,40) #30~40살 사이의 고객 수   #call
Age.Range.Freq(Age,40,50) #40~50살 사이의 고객 수   #call
Age.Range.Freq(Age,50,60) #50~60살 사이의 고객 수   #call
Age.Range.Freq(Age,60,70) #60~70살 사이의 고객 수   #call
Age.Range.Freq(Age,70,80) #70~80살 사이의 고객 수   #call
Age.Range.Freq(Age,80,90) #80~90살 사이의 고객 수   #call
#50~60의 클래스가 가장 큽니다. 보험사기자여부의 항목이 있는것으로 보아 해당 데이터셋은 증권사 또는 보험사의 고객데이터셋으로 추정되는데, 50~60세의 장년층은 일반적인 라이프사이클에 비춰 봤을때 저축해둔 자산이 비교적 많거나, 노후에 대비해 어느정도의 투자를 해뒀을 확률이 높을 나이입니다. 해당 통계결과는 이러한 사실을 반영하는것으로 보입니다.
#위의 Age 히스토그램에서 살펴본 내용을 조금 더 자세히 알아보겠습니다.
min(Age)   #최연소 고객은 2세
max(Age)   #최고령 고객은 89세
mean(Age)  #평균 나이 44.73세
median(Age) #중앙값 46세
#먼저 연령입니다 , 고객을 연령대별로 통계하겠습니다.
Age <- Customer$연령 #연령 열만 Age로 선언
hist(Age) #먼저 hist()함수로 해당 변수의 histogram에 관해 시각적으로 살펴보고 가겠습니다.
#이를 보고 40~60세 사이의 고객수가 가장 많음을 대략적으로 파악할 수 있습니다.
#먼저 연령입니다 , 고객을 연령대별로 통계하겠습니다.
Age <- Customer$연령 #연령 열만 Age로 선언
hist(Age) #먼저 hist()함수로 해당 변수의 histogram에 관해 시각적으로 살펴보고 가겠습니다.
#이를 보고 40~60세 사이의 고객수가 가장 많음을 대략적으로 파악할 수 있습니다.
#통계량
summary(Customer) #Customer내의 각 변수에 관한 기본적 통계 요약출력
#이중 제가 관심있는 몇가지 변수만 조금 더 구체적으로 살펴보겠습니다.
